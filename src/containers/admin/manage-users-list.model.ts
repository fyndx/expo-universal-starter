/**
 * @fileoverview User Management Model for Admin Interface
 *
 * This module provides reactive state management for paginated user lists in admin interfaces.
 * It leverages Legend State for optimal performance and Better Auth for secure user operations.
 *
 * Key features:
 * - Reactive state management with automatic UI updates
 * - Paginated user fetching with configurable page sizes
 * - Comprehensive error handling for API failures
 * - Type-safe interfaces for all data structures
 * - Reusable constants and interfaces for consistency
 *
 * @example Basic Usage
 * ```typescript
 * import { ManageUsersListModel } from './manage-users-list.model';
 *
 * const model = new ManageUsersListModel();
 * await model.fetchUsers();
 *
 * // Use with React
 * const state = model.obs.get();
 * ```
 *
 * @author Generated by GitHub Copilot
 * @since 1.0.0
 */

import { type Observable, observable } from "@legendapp/state";
import type { UserWithRole } from "better-auth/plugins/admin";
import { authClient } from "~/lib/auth-client";
import type { ApiStatus } from "~/utils/api";

/**
 * Default pagination configuration constants
 */
export const MANAGE_USERS_DEFAULTS = {
	/** Default number of users per page */
	PAGE_SIZE: 10,
	/** Default starting page number (1-indexed) */
	PAGE_NUMBER: 1,
} as const;

/**
 * API error structure for user management operations
 */
export interface UserManagementError {
	/** Error code from the API response */
	code?: string | undefined;
	/** Human-readable error message */
	message?: string | undefined;
	/** HTTP status code */
	status: number;
	/** HTTP status text */
	statusText: string;
}

/**
 * Query parameters for Better Auth admin listUsers API
 */
interface ListUsersQueryParams {
	/** Maximum number of users to return */
	limit?: string | number;
	/** Number of users to skip */
	offset?: string | number;
	/** Field to sort by */
	sortBy?: string;
	/** Sort direction */
	sortDirection?: "asc" | "desc";
	/** Search value when filtering */
	searchValue?: string;
	/** Field to search in */
	searchField?: "name" | "email";
	/** Search operator */
	searchOperator?: "contains" | "starts_with" | "ends_with";
	/** Field to filter by */
	filterField?: string;
	/** Value to filter by */
	filterValue?: string | number | boolean;
	/** Filter operator */
	filterOperator?: "eq" | "ne" | "lt" | "lte" | "gt" | "gte";
}

/**
 * User list data structure returned from the API
 */
export interface UserListData {
	/** Array of users with their roles */
	users: UserWithRole[];
	/** Total number of users available */
	total: number;
	/** Query limit applied to the request */
	limit: number | undefined;
	/** Query offset applied to the request */
	offset: number | undefined;
}

/**
 * Pagination metadata for managing user list state
 */
export interface PaginationMetadata {
	/** Number of users to display per page */
	pageSize: number;
	/** Current page number (1-indexed) */
	currentPage: number;
}

/**
 * Complete state interface for the ManageUsersListModel
 * Manages the reactive state for user list operations including loading, success, and error states
 */
interface IManageUsersListModel {
	/** Current API request status */
	status: ApiStatus;
	/** User list data from successful API responses */
	data?: UserListData;
	/** Error information from failed API requests */
	error?: UserManagementError | null;
	/** Pagination settings and current state */
	metadata: PaginationMetadata;
	/** Filters applied to the user list */
	filters: {
		/** Search term for user lookup */
		search: string;
		/** Selected user role for filtering */
		role: string;
		/** Selected user status for filtering */
		status: string;
	};
}

/**
 * Model for managing paginated user lists in admin interfaces.
 *
 * This class provides reactive state management for fetching and displaying
 * paginated user lists using Legend State for optimal performance. It handles
 * loading states, errors, and pagination metadata automatically.
 *
 * @example
 * ```typescript
 * const model = new ManageUsersListModel();
 *
 * // Fetch users
 * await model.fetchUsers();
 *
 * // Access reactive state
 * const state = model.obs.get();
 * console.log(`Loaded ${state.data?.users.length} users`);
 * ```
 */
export class ManageUsersListModel {
	/** Default number of users to display per page */
	public static readonly DEFAULT_PAGE_SIZE = MANAGE_USERS_DEFAULTS.PAGE_SIZE;
	/** Default starting page number */
	public static readonly DEFAULT_PAGE_NUMBER =
		MANAGE_USERS_DEFAULTS.PAGE_NUMBER;

	/** Observable state container for reactive updates */
	public readonly obs: Observable<IManageUsersListModel>;

	/**
	 * Creates a new instance of ManageUsersListModel with default pagination settings.
	 */
	constructor() {
		this.obs = observable<IManageUsersListModel>({
			status: "idle" as ApiStatus,
			metadata: {
				pageSize: ManageUsersListModel.DEFAULT_PAGE_SIZE,
				currentPage: ManageUsersListModel.DEFAULT_PAGE_NUMBER,
			},
			filters: {
				search: "",
				role: "all",
				status: "all",
			},
		});
	}

	/**
	 * Fetches users from the server with current pagination settings.
	 *
	 * This method:
	 * 1. Sets the status to "loading"
	 * 2. Calculates the appropriate offset based on current page and page size
	 * 3. Makes an API request using Better Auth's admin plugin
	 * 4. Updates the observable state with either success data or error information
	 *
	 * @returns Promise that resolves when the fetch operation completes
	 *
	 * @example
	 * ```typescript
	 * await model.fetchUsers();
	 *
	 * // Check the result
	 * const state = model.obs.peek();
	 * if (state.status === "success") {
	 *   console.log(`Loaded ${state.data.users.length} users`);
	 * }
	 * ```
	 */
	fetchUsers = async (): Promise<void> => {
		// Set loading state while preserving existing data
		this.obs.set({
			...this.obs.peek(),
			status: "loading",
		});

		try {
			// Get current state for pagination calculation
			const currentState = this.obs.peek();
			const offset =
				(currentState.metadata.currentPage - 1) *
				currentState.metadata.pageSize;

			// Prepare filters for the API request
			const { search, role, status } = currentState.filters;

			// Build query parameters for Better Auth admin endpoint
			const queryParams: ListUsersQueryParams = {
				limit: currentState.metadata.pageSize,
				offset,
				sortBy: "createdAt",
				sortDirection: "desc",
			};

			// Add search parameters if search term is provided
			if (search) {
				queryParams.searchValue = search;
				queryParams.searchField = "name"; // Search by name field
				queryParams.searchOperator = "contains";
			}

			// Add role filter if not "all"
			if (role !== "all") {
				queryParams.filterField = "role";
				queryParams.filterValue = role;
				queryParams.filterOperator = "eq";
			}

			// Add status filter if not "all" (for role filter, we need to use a different approach)
			// Note: If we need both role and status filters, we might need to handle this differently
			// as the API might not support multiple filters simultaneously
			if (status !== "all" && role === "all") {
				queryParams.filterField = "status";
				queryParams.filterValue = status;
				queryParams.filterOperator = "eq";
			}

			// Make API request to Better Auth admin endpoint
			const { data, error } = await authClient.admin.listUsers({
				query: queryParams,
			});

			// Handle API-level errors
			if (error) {
				this.obs.set({
					...this.obs.peek(),
					status: "error",
					error: {
						code: error.code,
						message: error.message,
						status: error.status,
						statusText: error.statusText,
					},
				});
				return;
			}

			// Update state with successful data
			this.obs.set({
				...this.obs.peek(),
				status: "success",
				data: {
					users: data.users,
					total: data.total,
					limit: "limit" in data ? data.limit : undefined,
					offset: "offset" in data ? data.offset : undefined,
				},
			});
		} catch {
			// Handle unexpected errors (network issues, parsing errors, etc.)
			this.obs.set({
				...this.obs.peek(),
				status: "error",
				error: {
					message: "An unexpected error occurred while fetching users",
					status: 500,
					statusText: "Internal Error",
				},
			});
		}
	};

	/**
	 * Navigates to the next page if available.
	 * Automatically fetches users for the new page.
	 */
	goToNextPage = async (): Promise<void> => {
		const currentState = this.obs.peek();
		const totalUsers = currentState.data?.total || 0;
		const totalPages = Math.ceil(totalUsers / currentState.metadata.pageSize);

		if (currentState.metadata.currentPage < totalPages) {
			this.obs.metadata.currentPage.set(currentState.metadata.currentPage + 1);
			await this.fetchUsers();
		}
	};

	/**
	 * Navigates to the previous page if available.
	 * Automatically fetches users for the new page.
	 */
	goToPreviousPage = async (): Promise<void> => {
		const currentState = this.obs.peek();

		if (currentState.metadata.currentPage > 1) {
			this.obs.metadata.currentPage.set(currentState.metadata.currentPage - 1);
			await this.fetchUsers();
		}
	};

	/**
	 * Navigates to a specific page number.
	 * Automatically fetches users for the new page.
	 *
	 * @param page - The page number to navigate to (1-indexed)
	 */
	goToPage = async (page: number): Promise<void> => {
		const currentState = this.obs.peek();
		const totalUsers = currentState.data?.total || 0;
		const totalPages = Math.ceil(totalUsers / currentState.metadata.pageSize);

		if (
			page >= 1 &&
			page <= totalPages &&
			page !== currentState.metadata.currentPage
		) {
			this.obs.metadata.currentPage.set(page);
			await this.fetchUsers();
		}
	};

	/**
	 * Sets the search filter and resets the current page to 1.
	 * Automatically fetches users with the new filter applied.
	 *
	 * @param search - The search term to apply
	 */
	setSearchFilter = (search: string) => {
		this.obs.filters.search.set(search);
		this.obs.metadata.currentPage.set(1); // Reset to first page when searching
		this.fetchUsers();
	};

	/**
	 * Sets the role filter and resets the current page to 1.
	 * Automatically fetches users with the new filter applied.
	 *
	 * @param role - The user role to filter by
	 */
	setRoleFilter = (role: string) => {
		this.obs.filters.role.set(role);
		this.obs.metadata.currentPage.set(1); // Reset to first page when filtering
		this.fetchUsers();
	};

	/**
	 * Sets the status filter and resets the current page to 1.
	 * Automatically fetches users with the new filter applied.
	 *
	 * @param status - The user status to filter by
	 */
	setStatusFilter = (status: string) => {
		this.obs.filters.status.set(status);
		this.obs.metadata.currentPage.set(1); // Reset to first page when filtering
		this.fetchUsers();
	};

	/**
	 * Clears all filters and resets the current page to 1.
	 * Automatically fetches users with no filters applied.
	 */
	clearFilters = () => {
		this.obs.filters.set({
			search: "",
			role: "all",
			status: "all",
		});
		this.obs.metadata.currentPage.set(1);
		this.fetchUsers();
	};
}
